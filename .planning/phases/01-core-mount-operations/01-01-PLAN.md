---
phase: 01-core-mount-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [cdev]
autonomous: false

must_haves:
  truths:
    - "User can run 'cdev mount' and host directory becomes accessible inside container"
    - "User can add '--readonly' flag and container cannot modify mounted files"
    - "User can restart container and mounted directories remain accessible"
    - "User can run 'cdev unmount' to remove a mount"
    - "User can run 'cdev mounts' and see all active bind mounts"
  artifacts:
    - path: "cdev"
      provides: "Mount management commands"
      exports: ["cmd_mount", "cmd_unmount", "cmd_mounts"]
      min_lines: 1550
  key_links:
    - from: "cmd_mount"
      to: "lxc config device add"
      via: "CLI invocation"
      pattern: "lxc config device add.*disk"
    - from: "cmd_unmount"
      to: "lxc config device remove"
      via: "CLI invocation"
      pattern: "lxc config device remove"
    - from: "cmd_mounts"
      to: "lxc config device show"
      via: "CLI invocation and parsing"
      pattern: "lxc config device show"
---

<objective>
Implement three new commands (mount, unmount, mounts) for managing bind mounts on running LXD containers with persistence.

Purpose: Enable developers to dynamically share host directories with containers without manual LXD device configuration.
Output: Working mount/unmount/mounts commands integrated into cdev CLI.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@cdev
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement mount command functions</name>
  <files>cdev</files>
  <action>
Add three new command functions to cdev following existing patterns (cmd_create, cmd_exec, etc.):

**cmd_mount():**
- Parse args: container name, host path, container path, optional --readonly flag
- Validate: container exists and is running, host path exists, container path is absolute
- Generate unique device name: "cdev-mount-{sanitized-container-path}" (replace / with -)
- Execute: `lxc config device add <container> <device-name> disk source=<host-path> path=<container-path> [readonly=true]`
- Error handling: Check if mount already exists at that path, handle permission errors
- Success message: "Mounted {host-path} -> {container}:{container-path}" with green color

**cmd_unmount():**
- Parse args: container name, mount identifier (device name OR container path)
- Validate: container exists
- If path given: resolve to device name by listing devices and matching path
- Execute: `lxc config device remove <container> <device-name>`
- Error handling: Mount not found, provide helpful message
- Success message: "Unmounted {container-path} from {container}" with green color

**cmd_mounts():**
- Parse args: container name, optional -h|--help
- Validate: container exists
- Execute: `lxc config device show <container>`, filter for type: disk devices
- Parse output to extract: device name, source (host path), path (container path), readonly status
- Display formatted table: Device Name | Host Path | Container Path | Mode (ro/rw)
- Handle empty case: "No bind mounts on {container}"

**Why not delegate to scripts/:** Simple LXD CLI wrappers (like cmd_exec, cmd_list). No complex logic requiring separate scripts.

**Naming convention:** Device names must be valid LXD identifiers (lowercase, alphanumeric, hyphens). Use pattern "cdev-mount-{sanitized-path}" to ensure uniqueness and recognizability.
  </action>
  <verify>
```bash
# Check functions exist and follow patterns
grep -E "^cmd_(mount|unmount|mounts)\(\)" cdev
# Check LXD commands are used correctly
grep "lxc config device" cdev
```
  </verify>
  <done>Three new functions (cmd_mount, cmd_unmount, cmd_mounts) exist in cdev with proper argument parsing, validation, LXD device operations, and error handling.</done>
</task>

<task type="auto">
  <name>Task 2: Add command routing and help text</name>
  <files>cdev</files>
  <action>
**Add help functions following show_*_help pattern:**

**show_mount_help():**
- Usage: `cdev mount <container> <host-path> <container-path> [--readonly]`
- Description: Mount host directory into running container as persistent disk device
- Arguments: container (existing running container), host-path (must exist), container-path (absolute path in container)
- Options: --readonly (mount read-only)
- Examples:
  - `cdev mount myapp ~/data /mnt/data`
  - `cdev mount myapp ~/config /etc/myapp --readonly`

**show_unmount_help():**
- Usage: `cdev unmount <container> <mount-name-or-path>`
- Description: Remove bind mount from container
- Arguments: container, mount identifier (device name like "cdev-mount-mnt-data" OR container path like "/mnt/data")
- Examples:
  - `cdev unmount myapp /mnt/data`
  - `cdev unmount myapp cdev-mount-mnt-data`

**show_mounts_help():**
- Usage: `cdev mounts <container>`
- Description: List all active bind mounts on container
- Arguments: container (existing container)
- Example: `cdev mounts myapp`

**Update main help text:**
- Add three new command entries to show_main_help() command list (after 'port' line):
  - `${GREEN}mount${RESET}       Mount host directory into container`
  - `${GREEN}unmount${RESET}     Remove bind mount from container`
  - `${GREEN}mounts${RESET}      List active bind mounts on container`

**Update command routing in main():**
- Add three new cases to the case statement around line 1444:
  - `mount) cmd_mount "$@" ;;`
  - `unmount) cmd_unmount "$@" ;;`
  - `mounts) cmd_mounts "$@" ;;`

**Why this order:** Help functions defined near top of file (with other show_* functions). Command routing at bottom in main(). Maintains existing cdev structure.
  </action>
  <verify>
```bash
# Check help functions exist
grep -E "^show_(mount|unmount|mounts)_help\(\)" cdev
# Check routing added
grep -E "mount\)|unmount\)|mounts\)" cdev
# Run help to see new commands
./cdev --help | grep -E "mount|unmount|mounts"
```
  </verify>
  <done>Help functions exist for all three commands, main help lists new commands, and command routing dispatches to cmd_mount/cmd_unmount/cmd_mounts functions.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete mount management system (mount, unmount, mounts commands) integrated into cdev CLI</what-built>
  <how-to-verify>
Test the complete mount workflow on a running container:

1. **Setup test container** (if needed):
   ```bash
   # Check if you have a running container
   ./cdev list
   # If not, create one:
   ./cdev create test-mount
   ```

2. **Test mount command:**
   ```bash
   # Create test directory with file
   mkdir -p /tmp/test-mount-data
   echo "test content" > /tmp/test-mount-data/testfile.txt

   # Mount into container
   ./cdev mount test-mount /tmp/test-mount-data /mnt/data

   # Verify file accessible from inside container
   ./cdev exec test-mount cat /mnt/data/testfile.txt
   # Expected: "test content"
   ```

3. **Test readonly flag:**
   ```bash
   # Mount readonly
   ./cdev mount test-mount /tmp/test-mount-data /mnt/readonly --readonly

   # Try to write (should fail)
   ./cdev exec test-mount sh -c "echo 'write test' > /mnt/readonly/write.txt" || echo "Write correctly blocked"
   ```

4. **Test mounts listing:**
   ```bash
   ./cdev mounts test-mount
   # Expected: Table showing both mounts (/mnt/data rw, /mnt/readonly ro)
   ```

5. **Test persistence across restart:**
   ```bash
   # Restart container
   lxc restart test-mount
   sleep 3

   # Verify mounts still accessible
   ./cdev exec test-mount cat /mnt/data/testfile.txt
   # Expected: "test content" (mount persisted)
   ```

6. **Test unmount:**
   ```bash
   # Unmount by path
   ./cdev unmount test-mount /mnt/data

   # Verify mount removed
   ./cdev mounts test-mount
   # Expected: Only /mnt/readonly shown

   # Try accessing unmounted path (should fail)
   ./cdev exec test-mount ls /mnt/data 2>&1 | grep -q "cannot access" && echo "Unmount successful"
   ```

7. **Test error handling:**
   ```bash
   # Try mounting non-existent host path
   ./cdev mount test-mount /nonexistent /mnt/test
   # Expected: Error message about host path not existing

   # Try mounting to non-running container
   lxc stop test-mount
   ./cdev mount test-mount /tmp /mnt/test
   # Expected: Error message about container not running
   ```

**Success criteria:** All 5 truths from must_haves are observable:
- ✓ Mount command creates accessible bind mount
- ✓ Readonly flag prevents modifications
- ✓ Mounts persist across container restart
- ✓ Unmount removes mount cleanly
- ✓ Mounts command lists all active mounts with correct details
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
After checkpoint approval:
- [ ] Three new commands callable via `cdev mount|unmount|mounts`
- [ ] Help text available via `cdev --help` and `cdev <command> --help`
- [ ] Mount/unmount operations work on running containers
- [ ] Mounts persist across container restarts (stored as LXD disk devices)
- [ ] Readonly flag enforced by LXD
- [ ] List command shows formatted table of mounts
</verification>

<success_criteria>
Phase 1 complete when all 5 requirements met:
- MOUNT-01: Mount host directory into running container ✓
- MOUNT-02: Support --readonly flag ✓
- MOUNT-03: Mounts persist across container restarts ✓
- MOUNT-04: Unmount bind mounts by name or path ✓
- MOUNT-05: List active bind mounts on container ✓
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-mount-operations/01-01-SUMMARY.md`
</output>
